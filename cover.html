
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>handler: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/mariojose123/PasswordCheckJsonAPI/internal/handler/handlerJSON.go (58.6%)</option>
				
				<option value="file1">github.com/mariojose123/PasswordCheckJsonAPI/internal/services/passwordChecker/passwordCheckerRE/passwordCheckerRE.go (55.6%)</option>
				
				<option value="file2">github.com/mariojose123/PasswordCheckJsonAPI/internal/services/passwordChecker/passwordCheckerRepetion/passwordcheckerrep.go (90.0%)</option>
				
				<option value="file3">github.com/mariojose123/PasswordCheckJsonAPI/internal/services/passwordChecker/pwCheckerLen/pwCheckerLen.go (90.0%)</option>
				
				<option value="file4">github.com/mariojose123/PasswordCheckJsonAPI/internal/services/services.go (21.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*This package handler its the server and handler function and  handle everything related to http request on password check project*/
package handler

import (
        "context"
        "encoding/json"
        "log"
        "net/http"

        "github.com/mariojose123/PasswordCheckJsonAPI/interfaces"
        "github.com/mariojose123/PasswordCheckJsonAPI/internal/structJson"
)

type HandlerPWCheck struct {
        passService interfaces.PWService
}

/*Create a new handler with its service */
func NewHandler(PWService interfaces.PWService) *HandlerPWCheck <span class="cov8" title="1">{
        return &amp;HandlerPWCheck{passService: PWService}
}</span>

/*Set the URL for the API */
func (h *HandlerPWCheck) PWRouter() <span class="cov0" title="0">{
        http.HandleFunc("/verify", h.verify)
        log.Fatal(http.ListenAndServe(":8080", nil))
}</span>

/*This function receives the JSON according to the specification on HTTP.request and send on w the JSON with the answer*/
func (h *HandlerPWCheck) verify(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method == "POST" </span><span class="cov0" title="0">{
                h.postVerify(w, r)
        }</span> else<span class="cov0" title="0"> {
                WrongMethodVerify(w)
        }</span>

}

/* POST  part of verifying func and the part required according to the specification because all API calls will be valid*/
func (h *HandlerPWCheck) postVerify(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{

        ctx := context.Background()
        jsonPW, err := DecodeJsonVerify(r)
        if err != nil </span><span class="cov0" title="0">{
                log.Print(err)
                BadRequestVerify(w)
        }</span>

        <span class="cov8" title="1">isCorrectPass, matchedRules := h.passService.CheckPW(ctx, jsonPW)

        jsonstruct := structJson.PStoJsonResponse(isCorrectPass, matchedRules)
        SendJsonVerify(w, jsonstruct)</span>
}

/*A method is call for every wrong Json on an API call for this Restful API*/
func WrongMethodVerify(w http.ResponseWriter) <span class="cov0" title="0">{
        w.WriteHeader(http.StatusMethodNotAllowed)
}</span>

func BadRequestVerify(w http.ResponseWriter) <span class="cov0" title="0">{
        w.WriteHeader(http.StatusBadRequest)
}</span>

/*Send Struct of service check PW as JSON to client*/
func SendJsonVerify(w http.ResponseWriter, jsonstruct structJson.JsonResponse) <span class="cov8" title="1">{
        w.WriteHeader(http.StatusCreated)
        w.Header().Set("Content-Type", "application/json")
        err := json.NewEncoder(w).Encode(jsonstruct)
        if err != nil </span><span class="cov0" title="0">{
                log.Print(err)
                w.WriteHeader(http.StatusInternalServerError)
        }</span>
}

/* Decode the JSON for verify, it is used on CheckPW service function*/
func DecodeJsonVerify(r *http.Request) (structJson.PSReceiveStructure, error) <span class="cov8" title="1">{
        var jsonPWraw structJson.PSReceiveStructureRaw
        decoder := json.NewDecoder(r.Body)
        err := decoder.Decode(&amp;jsonPWraw)
        if err != nil </span><span class="cov0" title="0">{
                return structJson.PSReceiveStructure{}, err
        }</span>
        <span class="cov8" title="1">jsonPW := structJson.NewPSReceiveStructure(jsonPWraw)
        return jsonPW, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">/* package for password checker that check if password Regular Expression is Matched x times in the password string*/
package passwordCheckerRE

import (
        "regexp"

        "github.com/mariojose123/PasswordCheckJsonAPI/internal/structJson"
)

/*Struct that checks repetition of regular Expression in the PW */
type PWCheckerMinRE struct {
        regexCompiled *regexp.Regexp
        nameConst     string
}

/*Create Password Checker(PWCheckerMinRE) that checks if a regular Expression happens x times */
func NewPWCheckRE(name string, regextext string) (PWCheckerMinRE, error) <span class="cov0" title="0">{
        regexCompiled, err := regexp.Compile(regextext)
        if err != nil </span><span class="cov0" title="0">{
                return PWCheckerMinRE{}, err
        }</span>
        <span class="cov0" title="0">return PWCheckerMinRE{nameConst: name, regexCompiled: regexCompiled}, nil</span>
}

/* Create Password Checker(PWCheckerMinRE) FOR Upper Case characters Min number of times*/
func NewPWCheckREUpperCase(name string) (PWCheckerMinRE, error) <span class="cov0" title="0">{
        return NewPWCheckRE(name, `[A-Z]`)
}</span>

/* Create Password Checker(PWCheckerMinRE) FOR Digits characters Min number of times*/
func NewPWCheckREDigits(name string) (PWCheckerMinRE, error) <span class="cov0" title="0">{
        return NewPWCheckRE(name, `[0-9]`)
}</span>

/* Create Password Checker(PWCheckerMinRE) FOR Special  characters Min number of times ACCORDING TO SPECIFICATION*/
func NewPWCheckRESpecialchar(name string) (PWCheckerMinRE, error) <span class="cov0" title="0">{
        return NewPWCheckRE(name, "["+regexp.QuoteMeta(`!@#$%^&amp;*()-+\/{}[]`)+"]")
}</span>

/* Create Password Checker(PWCheckerMinRE) FOR Lower Case characters Min number of times*/
func NewPWCheckRELowedCase(name string) (PWCheckerMinRE, error) <span class="cov0" title="0">{
        return NewPWCheckRE(name, `[a-z]`)
}</span>

/*Add Match if  PW has matched a Minimum of n regexp matchs  */
func (PWChecker PWCheckerMinRE) AddMatch(jsonStruct structJson.PSReceiveStructure, noMatch []string) []string <span class="cov8" title="1">{
        isMin := isMinRegexExpression(jsonStruct, PWChecker.regexCompiled, PWChecker.nameConst)
        if !isMin </span><span class="cov8" title="1">{
                return append(noMatch, PWChecker.nameConst)
        }</span>
        <span class="cov8" title="1">return noMatch</span>
}

/* Check if string has matched Minimum of n regexp */
func isMinRegexExpression(jsonStructure structJson.PSReceiveStructure, reExp *regexp.Regexp, RuleName string) bool <span class="cov8" title="1">{
        PW := jsonStructure.PW
        minRe, ok := jsonStructure.Rules[RuleName]
        if ok </span><span class="cov8" title="1">{
                return checkRegexLenPWMin(PW, reExp, minRe)
        }</span> else<span class="cov8" title="1"> {
                return true
        }</span>
}

/* Check if regex match minRe Times or more*/
func checkRegexLenPWMin(PW string, reExp *regexp.Regexp, minRe int) bool <span class="cov8" title="1">{
        return (len(reExp.FindAllString(PW, -1)) &gt;= minRe)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">/*package for Password Checker of repetition  */
package pwcheckerrep

import "github.com/mariojose123/PasswordCheckJsonAPI/internal/structJson"

/*A struct that Check repetition*/
type PWCheckerRepetion struct {
        nameConst string
}

/*Create Password Checker that check repetion*/
func NewPWCheck(constname string) PWCheckerRepetion <span class="cov0" title="0">{
        return PWCheckerRepetion{nameConst: constname}
}</span>

/* Add Match if PW has repeated characters*/
func (PWChecker PWCheckerRepetion) AddMatch(jsonStruct structJson.PSReceiveStructure, noMatch []string) []string <span class="cov8" title="1">{
        PW := jsonStruct.PW
        isRepeated := checkRepetionPW(PW)
        if isRepeated </span><span class="cov8" title="1">{
                return append(noMatch, PWChecker.nameConst)
        }</span>
        <span class="cov8" title="1">return noMatch</span>
}

/*Check if a string has repeated chars*/
func checkRepetionPW(PW string) bool <span class="cov8" title="1">{
        for indexChar := 0; indexChar &lt; len(PW)-1; indexChar++ </span><span class="cov8" title="1">{
                if PW[indexChar] == PW[indexChar+1] </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">/* Password Checker of minimun len x*/
package pwCheckerLen

import "github.com/mariojose123/PasswordCheckJsonAPI/internal/structJson"

/*A struct that check length of PW */
type PWCheckerLen struct {
        nameConst string
}

func NewPWCheck(constname string) PWCheckerLen <span class="cov0" title="0">{
        return PWCheckerLen{nameConst: constname}
}</span>

/*Add Match if  PW has reached minimum length  */
func (PWChecker PWCheckerLen) AddMatch(jsonStruct structJson.PSReceiveStructure, noMatch []string) []string <span class="cov8" title="1">{
        isMin := PWChecker.isMinLen(jsonStruct)
        if !isMin </span><span class="cov8" title="1">{
                return append(noMatch, PWChecker.nameConst)
        }</span>
        <span class="cov8" title="1">return noMatch</span>
}

/*Check if PW has Minimun Lenght */
func (checker PWCheckerLen) isMinLen(jsonStructure structJson.PSReceiveStructure) bool <span class="cov8" title="1">{
        PW := jsonStructure.PW
        minLen, ok := jsonStructure.Rules[checker.nameConst]
        if ok </span><span class="cov8" title="1">{
                return (len(PW) &gt;= minLen)
        }</span> else<span class="cov8" title="1"> {
                return true
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">/*
        Service that provides the function that checks the Password, has a list of constraints list

that it must follow, every constraint has a function that adds a string in a string array if Constrain IS NOT followed (AddMatch)

        Constrains parameters are defined on main.go
*/
package services

import (
        "context"

        "github.com/mariojose123/PasswordCheckJsonAPI/interfaces"
        "github.com/mariojose123/PasswordCheckJsonAPI/internal/services/passwordChecker/passwordCheckerRE"
        passwordcheckerrep "github.com/mariojose123/PasswordCheckJsonAPI/internal/services/passwordChecker/passwordCheckerRepetion"
        "github.com/mariojose123/PasswordCheckJsonAPI/internal/services/passwordChecker/pwCheckerLen"
        "github.com/mariojose123/PasswordCheckJsonAPI/internal/structJson"
)

/* Struct tha contains Contrains that are a array with password Checker*/
type PWService struct {
        constrainsPWRE []interfaces.PWChecker
}

/*
Init all constraints for PWService according to the specifications, Constraints parameters are defined on the main. go
the function could be generic for other password checkers but it has been implemented for the specification
The function add constrains checker for password on constrainsPWRE
*/
func NewPWService(UpperCaseString string, LowerCaseString string, DigitsString string, SpecialCharacters string,
        MinLenString string, RepeatedString string) (*PWService, error) <span class="cov0" title="0">{

        var checkers []interfaces.PWChecker

        pwCheckerUp, err := passwordCheckerRE.NewPWCheckREUpperCase(UpperCaseString)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;PWService{}, err
        }</span>
        <span class="cov0" title="0">pwCheckerLower, err := passwordCheckerRE.NewPWCheckRELowedCase(LowerCaseString)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;PWService{}, err
        }</span>
        <span class="cov0" title="0">pwCheckerDigits, err := passwordCheckerRE.NewPWCheckREDigits(DigitsString)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;PWService{}, err
        }</span>
        <span class="cov0" title="0">pwCheckerSpecial, err := passwordCheckerRE.NewPWCheckRESpecialchar(SpecialCharacters)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;PWService{}, err
        }</span>
        <span class="cov0" title="0">pwCheckerLen := pwCheckerLen.NewPWCheck(MinLenString)
        pwCheckerRepeated := passwordcheckerrep.NewPWCheck(RepeatedString)

        checkers = append(checkers, pwCheckerUp, pwCheckerLower,
                pwCheckerDigits, pwCheckerSpecial, pwCheckerLen, pwCheckerRepeated)
        return &amp;PWService{checkers}, nil</span>
}

/*
Given that the PWService has a array of Password Checkers add string of
Password Checker to noMatch string if noMatch string len is bigger
than 0 a Constrain was not followed
return True if all password matched are followed and
false Otherwise and NoMatch string array with every Constrain for Password that was not followed
*/
func (serv *PWService) CheckPW(ctx context.Context, jsonStructure structJson.PSReceiveStructure) (bool, []string) <span class="cov8" title="1">{

        var noMatch []string = make([]string, 0)
        /*Check every Password Checker of service according to specification constrains and add Match on noMatch
          to create JSON noMatch Array if constrain is not followed*/
        for _, constrain := range serv.constrainsPWRE </span><span class="cov8" title="1">{
                noMatch = constrain.AddMatch(jsonStructure, noMatch)
        }</span>
        /*Check if len of noMatch array acording to specification is empty*/
        <span class="cov8" title="1">if len(noMatch) &gt; 0 </span><span class="cov8" title="1">{
                return false, noMatch
        }</span>
        <span class="cov0" title="0">return true, noMatch</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
